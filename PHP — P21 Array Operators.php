<?php
//ОПЕРАТОРЫ МАССИВА

//Операторы массива — это операторы, которые используются в массивах. Кто бы мог подумать? Первый оператор, который мы рассмотрим, — это оператор +. Вы могли бы подумать, что этот оператор будет использоваться для объединения двух массивов, извлечения элементов из обоих массивов и их объединения в новый массив, но это не так.

//Напишем какой нибудь массив

$birds = [
    "Sparrow",
    "Pinguin",
    "Crow"
];

$cats = [
    "Tiger",
    "Lion",
    "Cheetah",
    "Puma"
];

$animals = $birds + $cats;//Данный оператор (+) в массивах, это не сложение, то есть он НЕ берет все из первого массива, и объединяет со вторым, и засовывает в третий $animals, пропишем Var_dump($animals) и там уже расскажу что как, чуть ниже

var_dump($animals);//Вывел нам все элементы из первого массива и еще один из второго, самый последний элемент, Потому что, Оператор + создает новый массив, который объединяет пары ключ/значение. Элементы с числовыми ключами 0, 1 и 2 существуют в первом массиве, поэтому они добавляются в массив $animals; они не перезаписываются вторым массивом. Во втором массиве есть дополнительный элемент с индексом 3, содержащий значение Puma, так что пара ключ/значение добавляется в новый массив $animals. То есть те элементы с одинаковыми индексами не будут перезаписываться вторым массивом, сначала берутся все элементы массива один, после все элементы массива, все элементы из первого добавляются к новому массиву, а далее код заходит во второй массив и проверяет индексы, и индекс того элемента, который не был добавлен из первого массива, будет добавлен в новый массив, в данном случае у нас три элемента из первого, и один последний элемент из 4. Вот такие вот дела


//Если действительно хотим объединить два массива вместе, содержащие элементы как из первого, так и из второго массивов, вам придется использовать встроенную PHP-функцию array_merge().

//Напишем и попробуем

$fav_animals = array_merge($birds, $cats);// Данный код, приведет к тому что у нас просто объединяться два массива, сначала будут добавлены элементы первого написанного в круглых скобках массива, а далее уже элементы из второго массива.

//Мы можем проверить равенство между двумя массивами, используя операторы равенства: равно (==), идентично (===), не равно (!=), не идентично (!==).

//Создадим два массива $car_1 и $car_2. Каждый из этих массивов будет содержать пары ключ/значение со строками, используемыми для ключей. Единственная разница между значениями заключается в том, что в $car_1 год будет целочисленным значением(числом обычным), а в $car_2 год будет строковым значением. Все остальное останется прежним.

$car_1 = [
    'year' => 2003,
    'make' => 'Chevy',
    'model' => 'Corvette'
];

$car_2 = [
    'year' => '2003',
    'make' => 'Chevy',
    'model' => 'Corvette'
];

var_dump($car_1 == $car_2);// Даст нам true, так как оператор == груб, он не смотрит на тип значения, а просто заходит и сравнивает все кроме типа

var_dump($car_1 === $car_2);// Вернет нам false, так как оператор === это оператор идентичности, который смотрит и на тип значения тоже, а так как типы разные, возвразает то что они не равны, одно число, другое строка с числом внутри

var_dump($car_1 != $car_2);//Вернет нам false так как тоже самое что и с ==, но уже наоборот, он видит что они равны, не проверяет тип, но как мы спрашивает НЕ РАВНЫ, ОН отвечает НЕТ, равны, то есть возвращает false

var_dump($car_1 !== $car_2);//Вернет true, так как сравнивая тип, наши значения не идентичны, а так как мы спросили, являются ли эти два модуля НЕ идентичными, то получили ответ ДА, они не идентичны. 
//Вот как то так.





























?>